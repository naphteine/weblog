---
title: "The Night of Uncertainty"
date: "2024-09-06T14:08:00+03:00"
draft: true
tags: ["programming languages"]
---

(To whoever reading this; sorry for this quick rough draft, I'm planning to improve this, yet it should contain my main point.)

I spent a whole sleepless night thinking about how to improve myself on programming. Of course the first thing to look for was the languages. As someone who tries to master frontend development, my main focus on the JavaScript and it's superset TypeScript. But I don't want to use JS for everything as one can imagine. So, I decided to use Go as my daily driver for writing fast, non-frontend code such as some bots and other things. Apart from being productive, I want to develop myself on programming too. I want to learn and experiment and experience. I had my eyes on Common Lisp since around 2017, if I recall correctly. Lately I been learning more about it and as I learn, I wanted to see it in action too. But setting up all the development environment, dealing with ASDF and Quicklisp and Qlot and everything just exhausted me. I was so tired and at one point in the night, even thinked that I wasn't suited to program at all, since all I was doing reading about languages, programming nothing, not even being able to setup a library (Trial) I wanted to use. It was the darkest hour of my night. I just wanted to rush and reach my goals, my ideals or they would slip away from my hands. I wanted to learn so many languages but when I was still couldn't understand one of them completely, was that really possible? Should I stay with my JavaScript lands and develop frontend software forever?

But then the sun started to rise and finally I've got the picture and the detail.

I read that sentence and it really make my road brighter; "Learn at least a half dozen programming languages"

I remember making a list of the languages that I found interesting sometime ago. It was a long list of 20-30 programming languages. I don't to really spend my life only learning programming languages. But limiting myself to this three feels kinda wrong too. So I started searching again. I looked into 'How to Become a Hacker' by catb, lists of programming languages, stackoverflow developer surveys and such. In the end, my list (which can be found on my main site over /stack) is just 10 languages and I feel like I did great job limiting myself down to these.

So my priority, my primary languages are of course, as mentioned before, are JavaScript and TypeScript. They're on the top of the list because of my area. I really didn't had any uses for them apart from web development, specially frontend.

My secondary is still the same, Go language. I have thought about this somewhat long actually. I wanted a language that's compiled, fast and easier to write. I don't need something very extensive. The only problem was Rust. As I understand, it could do the same things as good as Go, in some cases even better. I actually tried to learn Rust few years ago, but decided not to after reading Theo de Raadt's (views)[https://marc.info/?l=openbsd-misc&m=151233345723889] on integrating it into OpenBSD. So, in the end I decided to stay with my beloved Go, which I already had experience to some extend and actually enjoy writing.

My personal choice, for understanding the real beauty of programming, as other hackers pointed out and with my growing interest since I watched Serial Experiments Lain, is Common Lisp. Over time I tried Chicken Scheme, Haskell and Clojure but I found myself much more interested on Common Lisp. I believe I won't be able to use it for any real purposes but it will stay as my safe harbor. I will study and learn it and improve myself. If possible, one day I would like to contribute and even use it on commercial aspect (while not forgetting to support my community).

After that, comes the languages I find extraordinary and educative, but that I wouldn't prioritize over things above. Ada and Elixir. I especially find interest on Elixir because of the Ruby syntax. Just like the situation with Go, I had fun and productive experience with Ruby. Yet I didn't like the ecosystem too much. A similar language with more interesting features, such as being functional and concurrent. Ada, on the other hand. I been hearing about Ada on different websites and from friends. But my interest have hit maximum when I heard NATO tried to mandate use of it.

Just before the final, comes the Rust language. Despite I wouldn't make it my preferred daily driver, I'm still hopeful it's worth some efforts to learn, especially thinking White House included it in it's report as an alternative to unsafe languages, mainly C and C++.

Finally, comes the languages I had some experience in the past, don't really need to use them for any project of mine (except maybe some amateur hobby embedded projects?) but still want to include in my list; C, C++ and Perl. I'm really unsure about current status of Perl and I might be biased because I had read some of yorhel's Perl code and wanted to contribute to some of his projects.

---

Some pieces I've come across I think is worth reading;

http://www.catb.org/~esr/faqs/hacker-howto.html | I remember first reading this with broken English back in the 2014. It's nice to see it's still being updated.

https://www.paulgraham.com/rootsoflisp.html | Roots of Lisp. Especially recognizing that Lisp is the first (or one of the first) languages to be/use/create garbage collection, interpreted and real time changing the software. This is a good read generally on McCarthy's ideas.

https://norvig.com/21-days.html | Good essay on the rush. "Learn at least a half dozen programming languages" gives me all the hope.

http://archive.adaic.com/pol-hist/policy/mandate.txt | Mandate to use Ada.

https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf | BACK TO THE BUILDING BLOCKS: A PATH TOWARD SECURE AND MEASURABLE SOFTWARE